
# \brief Convert current metadata.xml to json
#
# \param[in] rods_zone  Zone name
# \param[in] coll_name  Collection name of metadata XML
# \param[in] group_name Group name of metadata XML
# \param[in] xml_data_name  Data name of metadata XML that requires transformation
##
# transformVaultMetadataXmlToJson(callback, rods_zone, vault_package, group_name, data_name)
def transformVaultMetadataXmlToJson(callback, rods_zone, coll_name, group_name, xml_data_name):
    # This function simply transforms given data_name to a Json data object. 
	# No further intelligence required further. 
	# Perhaps handling within vault??
	
	json_file = ''
	
	ofFlags = ''
	json_file = coll_name + '/yoda-metadata[' + str(int(time.time())) + '].json'
	ret_val = callback.msiDataObjCreate(json_file, ofFlags, 0)
	copyACLsFromParent(callback, json_file, "default")

	# Add item to provenance log.
	callback.iiAddActionLogRecord("system", coll_name, "Transformed yoda-metadata.xml to yoda-metadata.json")

	# transform the actual data	
        category = getCategory(callback, rods_zone, group_name)
	dictSchema = getActiveJsonSchemaAsDict(category)
		
	xmlData = getXmlDataAsDict(coll_name + "/" + xml_data_name)

	# ECHT APARTE FUNCTIE???
	newJsonDataString = transformYodaXmlDataToJson(dictSchema, xmlData)
	
	fileHandle = ret_val['arguments'][2]
	callback.msiDataObjWrite(fileHandle, newJsonDataString, 0)
	callback.msiDataObjClose(fileHandle, 0)
	
	callback.writeString("serverLog", "[ADDED METADATA.JSON AFTER TRANSFORMATION] %s" % (json_file))



# \brief Loop through all collections with yoda-metadata.xml data objects.
#        If NO yoda-metadata.json is found in that collection, the corresponding yoda-metadata.xml must be converted to json as an extra file - yoda-metadata.json
#
# \param[in] rods_zone Zone name
# \param[in] coll_id   First collection id of batch
# \param[in] batch     Batch size, <= 256
# \param[in] pause     Pause between checks (float)
#
# \return Collection id to continue with in next batch.
# If collection_id =0, no more collections are found containing yoda-metadata.xml
#
def iiCheckVaultMetadataXmlForTransformationToJsonBatch(callback, rods_zone, coll_id, batch, pause):
    # Find all research and vault collections, ordered by COLL_ID.
    iter = genquery.row_iterator(
        "ORDER(COLL_ID), COLL_NAME",
        "COLL_NAME like '/%s/home/vault-%%' AND DATA_NAME like 'yoda-metadata%%xml' AND COLL_ID >= '%d'" % (rods_zone, coll_id),
        genquery.AS_LIST, callback
    )

    # Check each collection in batch.
    for row in iter:
        coll_id = int(row[0])
        coll_name = row[1]
        pathParts = coll_name.split('/')

        try:
            group_name = pathParts[3]
            # elif 'vault-' in group_name:
                # Get vault package path.
            vault_package = '/'.join(pathParts[:5])
				
	    # First make sure that no metadata json file exists already in the vault collection .
	    # If so, no transformation is required.
	    # As it is unknown what the exact name is of the JSON file, use wildcards:

	    jsonFound = false
	    iter2 = genquery.row_iterator(
		 "ORDER(COLL_ID), COLL_NAME",
		 "DATA_NAME like 'yoda-metadata%%.json' AND COLL_ID >= '%d'" % (coll_id),
		 genquery.AS_LIST, callback
	    )
	    for row2 in iter2:
		jsonFound = true
		continue

	    if jsonFound == false:
		data_name = getLatestVaultMetadataXml(callback, vault_package)				
		if data_name != "":
		    transformVaultMetadataXmlToJson(callback, rods_zone, vault_package, group_name, data_name)
        except:
            pass

        # Sleep briefly between checks.
        time.sleep(pause)

        # The next collection to check must have a higher COLL_ID.
        coll_id = coll_id + 1
    else:
        # All done.
        coll_id = 0
        callback.writeString("serverLog", "[METADATA2JSON] Finished updating metadata.")

    return coll_id


# \brief Convert vault metadata XML to JSON - batchwise
#
# \param[in] coll_id  first COLL_ID to check - initial =0
# \param[in] batch    batch size, <= 256
# \param[in] pause    pause between checks (float)
# \param[in] delay    delay between batches in seconds
#
def iiCheckVaultMetadataXmlForTransformationToJson(rule_args, callback, rei):
    coll_id = int(rule_args[0])
    batch = int(rule_args[1])
    pause = float(rule_args[2])
    delay = int(rule_args[3])
    rods_zone = session_vars.get_map(rei)["client_user"]["irods_zone"]

    # Check one	batch of metadata schemas.
	# If no more collections are found, the function returns 0
    coll_id = iiCheckVaultMetadataXmlForTransformationToJsonBatch(callback, rods_zone, coll_id, batch, pause)

    if coll_id != 0:
        # Check the next batch after a delay.
        callback.delayExec(
            "<PLUSET>%ds</PLUSET>" % delay,
            "iiCheckVaultMetadataXmlForTransformationToJson('%d', '%d', '%f', '%d')" % (coll_id, batch, pause, delay),
            "")


